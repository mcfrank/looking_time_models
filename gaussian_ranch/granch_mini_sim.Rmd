---
title: "granch_mini"
author: "anjie & gal"
date: "3/19/2022"
output: html_document
---
```{r}
library(here)
library(tictoc)
library(tidyverse)
library(matrixStats)
source(here("helper/compute_prob.r"))
source(here("helper/granch_main_simulation_helper.R")) # this will import other helper functions 
source(here("helper/granch_sim_setup_helper.R")) # this will import functions that help with setting parameters 
```

```{r}

embedding_path <- here("embeddings/embedding_PCA.csv")

grid_mu_theta = get_embedding_range(embedding_path, step = 0.01)
grid_sig_sq = seq(0.001, 2, 0.2)
grid_y = get_embedding_range(embedding_path, step = 0.01)
grid_epsilon = seq(0.001, 1, 0.2)
hypothetical_obs_grid_n = 3 


#grid_mu_theta = c(0.001, 0.7)
#grid_y = c(0.001, 0.7)

# set model-related parameters 

em <- read_csv(embedding_path, col_names = FALSE)
mean_em <- mean(as.matrix(em))
sd_em <- sd(as.matrix(em))

mu_priors = c(mean_em)
V_priors = c(0.001) 
alpha_priors = c(1) 
beta_priors = c(1) 
epsilons = c(0.000001) 
mu_epsilon = c(0.001)
sd_epsilon = c(4)
world_EIGs = c(0.0000000000000000001) 
max_observation = 500

model_params <- set_granch_params(
                grid_mu_theta, grid_sig_sq, grid_y, grid_epsilon, hypothetical_obs_grid_n,
                mu_priors, V_priors, 
                alpha_priors, beta_priors, 
                epsilons, mu_epsilon, sd_epsilon,
                world_EIGs, max_observation)



# sketchy but works
# first one lp_mu_sig_sq
# second one df_y_given_mu_sig_sq
# third one prior_df 
ll_pre_calculated_df <- lapply(seq(1, nrow(model_params), 1), 
                       function(x){
                         lapply(seq(1, 3, 1), 
                                function(x){
                                  NULL
                                })
                       })

for(i in 1: nrow(model_params)){
  # 1st element lp_mu_sig_sq
  ll_pre_calculated_df[[i]][[1]] <- make_lp_mu_sig_sq(model_params$grid_mu_theta[[i]], 
                                                  model_params$grid_sig_sq[[i]], 
                                                  model_params$mu_prior[[i]], model_params$V_prior[[i]], 
                                                  model_params$alpha_prior[[i]], model_params$beta_prior[[i]])
  
  # 2nd element df_y_given_mu_sig_sq 
  
  ll_pre_calculated_df[[i]][[2]] <- make_df_y_given_mu_sig_sq(ll_pre_calculated_df[[i]][[1]], 
                                                  model_params$grid_y[[i]])
  

  ll_pre_calculated_df[[i]][[3]] <- make_prior_df(ll_pre_calculated_df[[i]][[1]], 
                                                  model_params$grid_epsilon[[i]], 
                                                  model_params$mu_epsilon[[i]], 
                                                  model_params$sd_epsilon[[i]])
}


# needs to get the precalculated dataframes in here 


model_params$df_y_given_mu_sig_sq <- lapply(ll_pre_calculated_df, function(x){x[[2]]})
model_params$prior_df <- lapply(ll_pre_calculated_df, function(x){x[[3]]})


# stims df will be something that taking in embeddings, but let's just ignore that for now
#test_stim <- get_stimulus(1, 1, embedding_path)%>% pull()
test_stim <- 0.7
stimuli_sequence <- tibble(V1 = rep(test_stim, 6), 
                   trial_number = seq(1, 6))

stims_df <- tibble(sequence_scheme = "BBBBBB", 
                   n_features = 1, 
                   on_features_n = 1 
                   ) %>% 
  mutate(stimuli_sequence = nest(stimuli_sequence, data = everything()))



full_params_df <- make_simulation_params(n_sim = 1,
                                        model_params, 
                                        stims_df)
# test_df <- full_params_df %>%
#   mutate(row_number = row_number()) %>% 
#   group_by(row_number) %>% 
#   nest()
# 
# params <- test_df[1, ]

```




```{r}
tic()
all_sims_res <- full_params_df %>%
  mutate(row_number = row_number()) %>% 
  group_by(row_number) %>% 
  nest() %>%
  mutate(results = map(data,
                       function(df) granch_main_simulation(params = df))) %>%
  unnest(cols = c(data, results))
toc()
```




```{r}
model <- all_sims_res$results[[2]]
info <- all_sims_res$results[[1]]

model %>% 
  ggplot(aes(x = t, y  = EIG))+ 
  geom_point()
```

```{r}
model %>% 
  filter(EIG < 0)
```

```{r}
# posterior
info[[5]][[1]]

# kl
info[[5]][[2]]

# post pred 
info[[5]][[3]]

# hypothetical posterior 
info[[5]][[4]]

```


```{r}
kl_div(info[[10]][[4]][[1]]$posterior, info[[10]][[1]]$posterior)

pruned_hypo_posterior <- info[[10]][[4]][[1]]
pruned_posterior <- info[[10]][[1]]

pruned_hypo_posterior$posterior[pruned_hypo_posterior$posterior == 0] <- 0.1
pruned_posterior$posterior[pruned_posterior$posterior == 0] <- 0.1

#hypo_post =  pruned_hypo_posterior$posterior[pruned_hypo_posterior$posterior!=0]
#post = pruned_posterior$posterior[pruned_posterior$posterior!=0]

kl_div(pruned_hypo_posterior$posterior, pruned_posterior$posterior)
#kl_div(hypo_post, post)
```


```{r}
lapply(seq(1, 50, 1), 
       function(x){
         info[[x]][[1]] %>% mutate(time_step = x) %>% ungroup()
       }) %>% 
  bind_rows() %>% 
  #filter(grid_sig_sq == 0.201) %>% 
  #group_by(time_step, grid_mu_theta) %>% 
  #summarise(m_posterior = mean(posterior)) %>%
  filter(time_step < 20 | time_step > 40) %>% 
  ggplot(aes(x = grid_mu_theta, y = posterior)) + 
  geom_point() + 
  facet_wrap(~time_step)
  

lapply(seq(1, 30, 1), 
       function(x){
         info[[x]][[1]] %>% mutate(time_step = x) %>% ungroup()
       }) %>% 
  bind_rows() %>% 
  filter(grid_sig_sq == 0.201) %>% 
  #group_by(time_step, grid_mu_theta) %>% 
  #summarise(m_posterior = mean(posterior)) %>%
  filter(time_step < 20) %>% 
  ggplot(aes(x = grid_mu_theta, y = posterior, color = grid_epsilon)) + 
  geom_jitter() + 
  facet_wrap(~time_step)
```




```{r}
all_sims_res %>% 
  ggplot(aes(x = t, y = EIG)) + 
  stat_summary(position = position_dodge(width = .1),fun.data = "mean_cl_boot")+ 
  facet_wrap(~row_number)
```


```{r}
all_sims_res %>% 
  group_by(row_number, params_id, n_features, sequence_scheme, stimulus_idx) %>% 
  filter(!is.na(stimulus_idx)) %>% 
  summarise(sample_n = n()) %>% 
  ggplot(aes(x = stimulus_idx, y = sample_n)) + 
  stat_summary(position = position_dodge(width = .1),fun.data = "mean_cl_boot") + 
  facet_wrap(~sequence_scheme)
```



```{r}
get_stimulus <- function(n_stim,n_dim, embedding_path){
  em <- read_csv(embedding_path, col_names = FALSE)
  em[sample(nrow(em), n_stim), 1:n_dim]
}

get_stimulus(1, 1, embedding_path)
```



```{r}
get_embedding_range <- function(embedding_path, step = 2){
  em <- read_csv(embedding_path, col_names = FALSE)
  return(seq(mean(as.matrix(em)) - 3*sd(as.matrix(em)), 
             mean(as.matrix(em)) + 3*sd(as.matrix(em)), 
             step
             )) 
}
```




