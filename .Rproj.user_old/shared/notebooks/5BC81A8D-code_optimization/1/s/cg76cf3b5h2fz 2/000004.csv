"0",""
"0","test_kl <- function(observations){"
"0","  "
"0","  "
"0","  "
"0","  unique_combination <- unique(observations %>% as.list())"
"0","  "
"0","  n_unique_combination = length(unique_combination)"
"0","  n_feature = ncol(observations)"
"0"," "
"0","  unique_combination_df <- tibble("
"0","    unique_combination = unique_combination, "
"0","    occurence = rep(0, n_unique_combination),"
"0","     n = rep(NA, n_unique_combination)"
"0","  )"
"0","  "
"0","  for (i in 1:n_unique_combination){"
"0","    current_combination = unique_combination_df[[i, 1]][[1]]"
"0","    for (f in 1:n_feature){"
"0","      "
"0","      if (identical(observations[,f][1] %>% pull, current_combination)){"
"0","        unique_combination_df[i, 2] <- unique_combination_df[i, 2] + 1"
"0","      }"
"0","      "
"0","    }"
"0","    "
"0","  }"
"0","  "
"0","  all_possible_combinations <- expand_grid("
"0","    unique_combination_df, "
"0","    hypothetical_observation = c(TRUE, FALSE)"
"0","   "
"0","  ) "
"0","  "
"0","  # calculate kl for specific feature "
"0","  # temporary measurement for now, latter needs to be solved along with multi-feature storage part "
"0","  calculate_kl_for_feature <- function(all_possible_combinations){"
"0","    "
"0","    n_possible_combination <- nrow(all_possible_combinations)"
"0","    "
"0","    all_possible_combinations$kl <- rep(NA_real_, n_possible_combination)"
"0","    "
"0","    # technically we should be able to find the last posterior"
"0","    prev_posterior_list <- lapply(unique(all_possible_combinations$unique_combination), "
"0","           function(x){"
"0","              grid_apprxoimation_with_observation_kl("
"0","                      tibble(x), "
"0","                      grid_theta,"
"0","                      grid_epsilon,  "
"0","                      alpha_prior, "
"0","                      beta_prior,"
"0","                      alpha_epsilon, "
"0","                      beta_epsilon) "
"0","           })"
"0","    "
"0","    # make concatenated observation "
"0","    "
"0","    # pass to post posterior "
"0","    # each option has two possibilities "
"0","    # initialize the thing "
"0","     post_posterior_list <- lapply(seq(1, n_possible_combination),"
"0","                                   function(x){"
"0","                                     expand_grid(theta = grid_theta, "
"0","                                                 epsilon = grid_epsilon)"
"0","                                   })"
"0","   "
"0","     for (i in 1:n_possible_combination){"
"0","      "
"0","      post_posterior_df = post_posterior_list[[i]]"
"0","      prev_observation_posterior = prev_posterior_list[[ceiling(i/2)]]"
"0","      post_posterior_list[[i]] <- update_posterior(previous_posterior_df =  prev_observation_posterior,"
"0","                                                         current_posterior_df = post_posterior_list[[i]], "
"0","                                                         (i%%2 == 1), "
"0","                                                         grid_theta, grid_epsilon)"
"0","       "
"0","     }"
"0","    "
"0","   "
"0",""
"0",""
"0",""
"0","      "
"0","      for (s in 1:n_possible_combination){"
"0","        "
"0","        all_possible_combinations$kl[s] <- get_kl(post_posterior_list[[s]]$posterior, "
"0","                                                  prev_posterior_list[[ceiling(s/2)]]$posterior)"
"0","        "
"0","        "
"0","      }"
"0","      "
"0","      "
"0","      return (all_possible_combinations)"
"0","      "
"0","  "
"0","  "
"0","      "
"0","      }"
"0","  "
"0","  "
"0","  "
"0","  "
"0","  "
"0","  "
"0","  "
"0","  all_possible_combination_df <- calculate_kl_for_feature(all_possible_combinations)"
"0","  "
"0","  "
"0","  "
"0","  "
"0","  "
"0","  "
"0","  "
"0","  "
"0","  # figure out number of different compositions of the feature possibility "
"0","  l_comb <- lapply(unique_combination_df$occurence, "
"0","         function(x){partitions::compositions(x, 2)}) "
"0","    "
"0","  list_combination <- lapply(seq(1, length(l_comb)), "
"0","                             function(x){as.list(data.frame(as.matrix(l_comb[[x]])))}) %>% "
"0","    cross()"
"0","  "
"0","  matrix_combination <- sapply(list_combination, function(x){unlist(x)})"
"0","  "
"0","  "
"0","  "
"0","  number_of_unique_combinations = prod(sapply( unique_combination_df$occurence, "
"0","                                          function(x){choose(x+1, 1)}))"
"0","  "
"0","  assertthat::are_equal(length(list_combination), number_of_unique_combinations)"
"0","  "
"0","  "
"0"," # figure out all the possible combinations "
"0","  list_all_possible_combination <- lapply(seq(1,  number_of_unique_combinations , 1), "
"0","                                          function(x){all_possible_combinations})"
"0","  "
"0","  for (i in 1:number_of_unique_combinations){"
"0","    list_all_possible_combination[[i]]$n <- matrix_combination[, i]"
"0","    "
"0","  }"
"0","  "
"0","  # probably want to use some assert to make sure it make sense? "
"0","  "
"0","  kl_list <- lapply(list_all_possible_combination, "
"0","         function(df){"
"0","           "
"0","           sum(df$n * all_possible_combination_df$kl)"
"0","         })"
"0","  "
"0","  "
"0","  "
"0","  return (kl_list)"
"0",""
"0","}"
"0",""
"0",""
"0","multifeature_stimuli <- generate_creature_sequence(block_length = trials_per_block, "
"0","  deviant_positions = deviant_positions,  # takes a vector, "
"0","  total_feature = 5, "
"0","  feature_theta = feature_theta, "
"0","  feature_number = num_features_simple, "
"0","  dissimilar_ratio = dissimilarity_ratio)"
"2","New names:
* X -> X...1
* X -> X...2
* X -> X...3
* X -> X...4
* X -> X...5
"
"2","New names:
* X -> X...1
* X -> X...2
* X -> X...3
* X -> X...4
* X -> X...5
"
"2","New names:
* X -> X...1
* X -> X...2
* X -> X...3
* X -> X...4
* X -> X...5
"
"0","observations = multifeature_stimuli[startsWith(names(multifeature_stimuli), "
"0","                                                                 ""V"")]"
"0",""
"0","posterior <- grid_apprxoimation_with_observation("
"0","  observations, "
"0","  grid_theta,"
"0","  grid_epsilon,  "
"0","  alpha_prior, "
"0","  beta_prior,"
"0","  alpha_epsilon, "
"0","  beta_epsilon)   "
"0",""
"0","all_possible_creatures <- get_possible_creatures(observations[1, ])"
"0",""
"0",""
"0","old_get_kl <- function(observations){"
"0","  "
"0",""
"0","kls_df <- get_possible_kls("
"0","  observations, "
"0","  all_possible_creatures, "
"0","  posterior, "
"0","  grid_theta = grid_theta, "
"0","  grid_epsilon = grid_epsilon, "
"0","  alpha_prior = alpha_prior, "
"0","  beta_prior = beta_prior,"
"0","  alpha_epsilon = alpha_epsilon, "
"0","  beta_epsilon = beta_epsilon) "
"0","return(kls_df) "
"0"," #return(round(unique(kls_df$kl),8) %>% sort())"
"0",""
"0","}"
"0",""
"0","new_get_kl <- function(observations){"
"0","  "
"0"," return( round(test_kl(observations) %>% unlist() %>% sort(), 8))"
"0","}"
"0",""
"0","old_res <- old_get_kl(observations)"
"0","new_res <- new_get_kl(observations)"
"0",""
"0","bm_kl <- bench::mark(old_get_kl(observations), "
"0","            new_get_kl(observations))"
"2","Error: Each result must equal the first result:
`old_get_kl(observations)` does not equal `new_get_kl(observations)`
"
