---
title: "scratch rmd for hiearchical"
author: "anjie & gal"
date: "12/15/2021"
output: html_document
---

```{r}
library(tidyverse)
```

some sketch for lambda 
```{r}


# ---------------- score_yi_given_theta ---------------------
choose_world_with_lambda <- function(w, lambda){
  # a cooler way to say that if w = 1 then theta if yi = 0 then yi = 1-theta? 
  dbinom(w, size = 1, prob = lambda, log = TRUE)
}

# ---------------- score_theta ---------------------
score_lambda <- function(lambda, alpha_lambda, beta_lambda){
  dbeta(x = lambda, shape1 = alpha_lambda, shape2 = beta_lambda, log = TRUE)
}
```



now we are going to pretend that we are in a two concepts only world 

first we will set up the data frame to keep track fo the two thetas 

these two currently look identical so maybe they are indeed identical 
```{r}
grid_theta = seq(0.1, 1, 0.2)
grid_epsilon = seq(0.1, 1, 0.2)


theta_one_alpha = 10
theta_one_beta = 1

theta_two_alpha = 1
theta_two_beta = 10


gamma <- 0.6

lp_y_given_theta_one = tibble(theta = grid_theta, 
                            lp_theta_one = score_theta(grid_theta, theta_one_alpha, theta_one_beta),
                            lp_y_ONE_given_theta_ONE = score_yi_given_theta(yi = 1, 
                                                                     theta = grid_theta), 
                            lp_y_ZERO_given_theta_ONE = score_yi_given_theta(yi = 0, 
                                                                      theta = grid_theta))
 
lp_y_given_theta_two = tibble(theta = grid_theta, 
                            lp_theta_two = score_theta(grid_theta, theta_two_alpha, theta_two_beta),
                            lp_y_ONE_given_theta_TWO = score_yi_given_theta(yi = 1, 
                                                                     theta = grid_theta), 
                            lp_y_ZERO_given_theta_TWO = score_yi_given_theta(yi = 0, 
                                                                      theta = grid_theta))
  
  
  

  
lp_z_given_theta <- initialize_z_given_theta(grid_theta, grid_epsilon, 
                                                  20, # max observation 
                                                  1) # n features

# lp_z_given_theta is probably not going to change so we good here 

lp_z_given_theta[[1]]


model <- initialize_model(0.06, 20, 1)
model$t[1] <- 1
model$stimulus_idx[1] <- 1
model$f1[1] <- TRUE
model
```


```{r}



# ---------------- score_z_given_theta ---------------------
# Pretend we are always having two concepts
# main function updating likelihood
# returns a dataframe of cumulative log probabilities, p(z | theta)
  score_z_given_theta <- function(t, # timestep
                                f, # feature
                                lp_y_given_theta_one, # cached likelihoods
                                lp_y_given_theta_two, 
                                lp_z_given_theta, # more complicated 
                                model) {
  
  # set up current variables
  this_lp_z_given_theta <- lp_z_given_theta[[t]][[f]]

  grid_epsilon <- unique(this_lp_z_given_theta$epsilon) # just to get the value
  grid_theta <- unique(this_lp_z_given_theta$theta)
  
  
  this_stimulus_idx <- model$stimulus_idx[t]
  
  # need to compute over all noisy observations of this stimulus
  observations_this_stimulus <- filter(model, stimulus_idx == this_stimulus_idx) %>%
    select(paste0("f", f)) %>%
    pull()
  
  # initialize log p(z|y)
  lp_z_given_y = tibble(epsilon = grid_epsilon)
  
  # compute probabilities over all observations of this stimulus
  lp_z_given_y$z_given_y_ONE = rowSums(sapply(observations_this_stimulus, 
                                              function(x){ score_z_ij_given_y(x, 1, grid_epsilon)}))
  lp_z_given_y$z_given_y_ZERO = rowSums(sapply(observations_this_stimulus, 
                                               function(x){ score_z_ij_given_y(x, 0, grid_epsilon)}))
  
  # clever expansion with cached likelihoods
  lp_z_y_theta <- expand_grid(lp_y_given_theta_one, lp_z_given_y) %>% 
    left_join(lp_y_given_theta_two, by = "theta") %>% 
    mutate(log_gamma = log(gamma), 
           log_1minusgamma = log(1-g))
  
  # NEEDS TO BE FIXED TO TAKE CARE OF THE ROWWISE THINGS
 lp_z_y_theta$z_given_theta <- logSumExp(c(lp_z_y_theta$z_given_y_ONE + 
                                             
                                             logSumExp(c(lp_z_y_theta$lp_y_ONE_given_theta_ONE + log(gamma) + lp_z_y_theta$lp_theta_one, 
                                                         lp_z_y_theta$lp_y_ONE_given_theta_TWO + log(1-gamma) + lp_z_y_theta$lp_theta_two
                                                          )), 
                                           lp_z_y_theta$z_given_y_ZERO + 
                                             logSumExp(c(lp_z_y_theta$lp_y_ZERO_given_theta_ONE + log(gamma) + lp_z_y_theta$lp_theta_one, 
                                                         lp_z_y_theta$lp_y_ZERO_given_theta_TWO + log(1-gamma) + lp_z_y_theta$lp_theta_two
                                                          ))))
  
  
  # likelihood of all samples for current stimulus
  this_lp_z_given_theta$lp_z_given_theta <- 
    rowLogSumExps(lx = as.matrix(this_lp_z_given_theta[,c("lp_z_y_ONE", "lp_z_y_ZERO")]))
  
  # add in likelihood for last sample from last stimulus, which includes all prior obs
  if (this_stimulus_idx > 1) {
    last_stim_last_t <- max(model$t[model$stimulus_idx == this_stimulus_idx - 1], na.rm=TRUE)
    this_lp_z_given_theta$lp_z_given_theta <- this_lp_z_given_theta$lp_z_given_theta + 
      lp_z_given_theta[[last_stim_last_t]][[f]]$lp_z_given_theta
  }
  
  return(this_lp_z_given_theta)
}

```

