---
title: "scratch rmd for hiearchical"
author: "anjie & gal"
date: "12/15/2021"
output: html_document
---

```{r}
library(tidyverse)
```

some sketch for lambda 
```{r}


# ---------------- score_yi_given_theta ---------------------
choose_world_with_lambda <- function(w, lambda){
  # a cooler way to say that if w = 1 then theta if yi = 0 then yi = 1-theta? 
  dbinom(w, size = 1, prob = lambda, log = TRUE)
}

# ---------------- score_theta ---------------------
score_lambda <- function(lambda, alpha_lambda, beta_lambda){
  dbeta(x = lambda, shape1 = alpha_lambda, shape2 = beta_lambda, log = TRUE)
}
```


# stuff we need for two concepts world 

```{r}
test_model <- initialize_model(0.2, 20, 1)
test_model$t[1:10] <- seq(1, 10)
test_model$stimulus_idx[1:10] <- c(1, 1, 1, 2, 2, 3, 3, 3, 4, 4)
test_model$f1[1:10] <- rep(TRUE, 10)

test_model
```

# all for single concept right now, 

```{r}
# a list of dataframes that keep tracks of all the combinations possible 
# index corresponds to trial number 
# dataframes correspond to 
initialize_two_concepts_combinations <- function(total_trial_number){
  
  lapply(1:total_trial_number, 
         function(trial_number){
            as.matrix(expand.grid(as.data.frame(sapply(1:trial_number, 
                  FUN = function(i){c(1,2)}))))
         })
  
}
all_two_concepts_combination <- initialize_two_concepts_combinations(4)
current_stimulus_two_concept_combination <- all_two_concepts_combination[[4]]

# a function to index into the observation so that we can update the theta accordingly 

# a loop to go through all the possibilities 
i = 8
current_combo <- current_stimulus_two_concept_combination[i, ]

get_observation_for_concept <- function(concept, current_combo, model){

  # stimuli that comes from the specific concept 
  stimuli_from_concept <- which(current_combo == concept)
  
  # observation from those stimuli 
  obs_t <- (model$t[model$stimulus_idx %in% stimuli_from_concept])[!is.na(model$t[model$stimulus_idx %in% stimuli_from_concept])]

  return(obs_t)
  
}

obs_t_from_concept_one <- get_observation_for_concept(1, current_combo, model)
obs_t_from_concept_two <- get_observation_for_concept(2, current_combo, model)


# a function that put all the pieces together for likelihood in two world concept 
# takes gamma, needs to take into account of what the 



```


```{r}

# set up the dataframe to be used 

lp_z_given_y = tibble(epsilon = grid_epsilon)
lp_y_given_theta = tibble(theta = grid_theta, 
                            lp_y_ONE_given_theta = score_yi_given_theta(yi = 1, 
                                                                     theta = grid_theta), 
                            lp_y_ZERO_given_theta = score_yi_given_theta(yi = 0,
                                                                         theta = grid_theta)) 


lp_z_theta <- expand_grid(theta = grid_theta, 
                          epsilon = grid_epsilon)
lp_z_theta$z_theta <- rep(0, length(lp_z_theta$theta))



score_all_observations_from_this_stimulus <- function(f, model, stimulus_idx, 
                                                 lp_z_given_y, 
                                                 lp_y_given_theta){
  
  # select the feature to be updated and get all the observation on that particular stimulus  
  f_index <- paste0("f", f)
  observation_on_current_stimulus <- model$`f_index`[model$stimulus_idx == i][!is.na(model$`f_index`[model$stimulus_idx == i])]
  
  #calculate: lp(z|y=1) and lp(z|y=0)
  lp_z_given_y$z_given_y_ONE = rowSums(sapply(observation_on_current_stimulus, 
                                              function(x){ score_z_ij_given_y(x, 1, grid_epsilon)}))
  lp_z_given_y$z_given_y_ZERO = rowSums(sapply(observation_on_current_stimulus, 
                                               function(x){ score_z_ij_given_y(x, 0, grid_epsilon)}))

  # combining with lp(y=1|theta) and lp(y=0|theta)
  lp_z_y_theta <- expand_grid(lp_y_given_theta, lp_z_given_y)
  
  # calculate p(z|theta) = p(z|y=1) p(y=1|theta) + p(z|y = 0)p(y=0|theta) 
  lp_z_y_theta$lp_z_y_ONE <- lp_z_y_theta$lp_y_ONE_given_theta + lp_z_y_theta$z_given_y_ONE
  lp_z_y_theta$lp_z_y_ZERO <- lp_z_y_theta$lp_y_ZERO_given_theta + lp_z_y_theta$z_given_y_ZERO
  lp_z_y_theta$lp_z_given_theta <- rowLogSumExps(lx = as.matrix(this_lp_z_given_theta[,c("lp_z_y_ONE", "lp_z_y_ZERO")]))
  
  return(lp_z_y_theta)
  
}

score_z_given_theta_for_concept <- function(f, concept, current_combo, model, 
                         lp_z_given_y, lp_y_given_theta){
  
  # looping through # of the stimuli that has been seen
  stimulus_idx_from_concept <- which(current_combo == concept)
  
  # setting up for accumulating across different stimuli on the concept 
  all_lp_z_theta <- expand_grid(theta = grid_theta, 
                          epsilon = grid_epsilon)
  all_lp_z_theta$lp_z_given_theta <- rep(0, length(all_lp_z_theta$theta))
  
  for (i in stimulus_idx_from_concept){
    this_lp_z_given_theta <- score_all_observations_from_this_stimulus(f, model, 
                                                         stimulus_idx = i, 
                                                        lp_z_given_y, 
                                                        lp_y_given_theta)
    # accumulating across stimulus from same concept   
    all_lp_z_theta$lp_z_given_theta  <-  all_lp_z_theta$lp_z_given_theta  +  this_lp_z_given_theta$lp_z_given_theta
  }
  
  return(all_lp_z_theta)
}

# calculating p(\theta_{gamma} | \bar{z})

posterior <- expand_grid(theta = grid_theta,
                              epsilon = grid_epsilon)
  # not sure when do we really need the non-log one, save some $$$  
posterior$unnormalized_log_posterior <- NA_real_
posterior$log_posterior <- NA_real_
posterior$posterior <- NA_real_

score_posterior_for_concept <- function(concept_prior, concept_likelihood, concept_posterior){
  # likelihood * prior
  concept_posterior$unnormalized_log_posterior <- concept_likelihood$lp_z_given_theta + 
    concept_prior$lp_theta + 
    concept_prior$lp_epsilon
  
  # normalize
  concept_posterior$log_posterior <- concept_posterior$unnormalized_log_posterior - matrixStats::logSumExp(concept_posterior$unnormalized_log_posterior)
  concept_posterior$posterior <- exp(concept_posterior$log_posterior)
  return(concept_posterior)
}

```


some psuedo code for how are we going about this 
```{r}
# observing a new thing 
# OBS
# FIGURE OUT WHICH TRIALS WE ARE ON
all_possible_combination <- initialize_two_concepts_combinations(n_of_trials)



# Set up a bunch of dataframe to be reused 
lp_z_given_y = tibble(epsilon = grid_epsilon)
lp_y_given_theta = tibble(theta = grid_theta, 
                            lp_y_ONE_given_theta = score_yi_given_theta(yi = 1, 
                                                                     theta = grid_theta), 
                            lp_y_ZERO_given_theta = score_yi_given_theta(yi = 0,
                                                                         theta = grid_theta)) 


lp_z_theta <- expand_grid(theta = grid_theta, 
                          epsilon = grid_epsilon)
lp_z_theta$z_theta <- rep(0, length(lp_z_theta$theta))


posterior <- expand_grid(theta = grid_theta,
                              epsilon = grid_epsilon)
  # not sure when do we really need the non-log one, save some $$$  
posterior$unnormalized_log_posterior <- NA_real_
posterior$log_posterior <- NA_real_
posterior$posterior <- NA_real_


# figure out the # of stimulus_idx i'm on

current_two_concepts_combination <- all_two_concepts_combination[[current_stimulus_idx]]

# loop through all features 
for (f in ALL_FEATURES){
  
   # do some calulcation for the one concept world 
  ONE_CONCEPT_WORLD_RESULTS <- SOME_CALC
  
  # do some calculation for the two concept world 
  # for each feature loop through all possible combinations
  all_combo_y_ONE_likelihood <- #some length vector 
  all_combo_y_ZERO_likelihood <- # some length vector 
  
  for(i in nrow(current_two_concepts_combination)){
    
    # first figure out which combo we are on
    current_combo <- current_two_concepts_combination[i, ]
    
    # calculate posterior for concept one 
    likelihood_for_concept_one <- score_z_given_theta_for_concept(...)
    posterior_for_concept_one <- score_posterior_for_concept(...)
    
    # calculate posterior for concept two 
    likelihood_for_concept_two <- score_z_given_theta_for_concept(...)
    posterior_for_concept_two <- score_posterior_for_concept(...)
  
    # figure out how many lambda to attach to 
    # this is buggy, needs to take into acount of the 0 
    n_concept_one_occurence <- table(current_combo)[[1]]
    n_concept_two_occurence <- table(current_combo)[[2]]
    
  
    # figure out the p(y|theta_1) p(y|theta_2) components 
    lp_y_ONE_theta_1 <- lp_y_given_theta$lp_y_ONE_given_theta
    lp_y_ONE_theta_2 <- lp_y_given_theta$lp_y_ONE_given_theta
    lp_y_ZERO_theta_1 <- lp_y_given_theta$lp_y_ZERO_given_theta
    lp_y_ZERO_theta_2 <- lp_y_given_theta$lp_y_ZERO_given_theta
    
    # putting everything together 
    lp_combo_y_ONE_likelihood <- (lp_y_ONE_theta_1 * n_concept_one_occurence) + (lp_y_ONE_theta_2 * n_concept_one_occurence) + 
      (lp_gamma_1 * n_concept_one_occurence) + (lp_gamma_2 * n_concept_two_occurence)
    
    lp_combo_y_ZERO_likelihood <- (lp_y_ZERO_theta_1 * n_concept_one_occurence) + (lp_y_ZERO_theta_2 * n_concept_one_occurence) + 
      (lp_gamma_1 * n_concept_one_occurence) + (lp_gamma_2 * n_concept_two_occurence)
    
    # some sort of adding all combo together 
    all_combo_y_ONE_likelihood <- ACC #accumulating 
    all_combo_y_ZERO_likelihood <-ACC #accumulating 
    
  }
  # get observation accumulation 
  lp_z_given_y$z_given_y_ONE = rowSums(sapply(observation_till_this_stimulus, 
                                              function(x){ score_z_ij_given_y(x, 1, grid_epsilon)}))
  
  lp_z_given_y$z_given_y_ZERO = rowSums(sapply(observation_till_this_stimulus, 
                                              function(x){ score_z_ij_given_y(x, 0, grid_epsilon)}))
  
  
 
  # finally putting everything gether  
  # probalby needs to be rowwise or sth like that
  TWO_CONCEPT_WORLD <- logSumExp(lp_z_given_y$z_given_y_ONE +  all_combo_y_ONE_likelihood, 
            lp_z_given_y$z_given_y_ZERO +  all_combo_y_ZERO_likelihood)
  
  FINAL_RESULTS <- logSumExp((ONE_CONCEPT_WORLD + LOG_LAMBDA), 
                             (TWO_CONCEPT_WORLD + LOG(1-LAMBDA)))
  
  
}

```


now we are going to pretend that we are in a two concepts only world 

first we will set up the data frame to keep track fo the two thetas 

these two currently look identical so maybe they are indeed identical 
```{r}
grid_theta = seq(0.1, 1, 0.2)
grid_epsilon = seq(0.1, 1, 0.2)


theta_one_alpha = 10
theta_one_beta = 1

theta_two_alpha = 1
theta_two_beta = 10


gamma <- 0.6

lp_y_given_theta_one = tibble(theta = grid_theta, 
                            lp_theta_one = score_theta(grid_theta, theta_one_alpha, theta_one_beta),
                            lp_y_ONE_given_theta_ONE = score_yi_given_theta(yi = 1, 
                                                                     theta = grid_theta), 
                            lp_y_ZERO_given_theta_ONE = score_yi_given_theta(yi = 0, 
                                                                      theta = grid_theta))
 
lp_y_given_theta_two = tibble(theta = grid_theta, 
                            lp_theta_two = score_theta(grid_theta, theta_two_alpha, theta_two_beta),
                            lp_y_ONE_given_theta_TWO = score_yi_given_theta(yi = 1, 
                                                                     theta = grid_theta), 
                            lp_y_ZERO_given_theta_TWO = score_yi_given_theta(yi = 0, 
                                                                      theta = grid_theta))
  
  
  

  
lp_z_given_theta <- initialize_z_given_theta(grid_theta, grid_epsilon, 
                                                  20, # max observation 
                                                  1) # n features

# lp_z_given_theta is probably not going to change so we good here 

lp_z_given_theta[[1]]


model <- initialize_model(0.06, 20, 1)
model$t[1] <- 1
model$stimulus_idx[1] <- 1
model$f1[1] <- TRUE
model
```


```{r}



# ---------------- score_z_given_theta ---------------------
# Pretend we are always having two concepts
# main function updating likelihood
# returns a dataframe of cumulative log probabilities, p(z | theta)
  score_z_given_theta <- function(t, # timestep
                                f, # feature
                                lp_y_given_theta_one, # cached likelihoods
                                lp_y_given_theta_two, 
                                lp_z_given_theta, # more complicated 
                                model) {
  
  # set up current variables
  this_lp_z_given_theta <- lp_z_given_theta[[t]][[f]]

  grid_epsilon <- unique(this_lp_z_given_theta$epsilon) # just to get the value
  grid_theta <- unique(this_lp_z_given_theta$theta)
  
  
  this_stimulus_idx <- model$stimulus_idx[t]
  
  # need to compute over all noisy observations of this stimulus
  observations_this_stimulus <- filter(model, stimulus_idx == this_stimulus_idx) %>%
    select(paste0("f", f)) %>%
    pull()
  
  # initialize log p(z|y)
  lp_z_given_y = tibble(epsilon = grid_epsilon)
  
  # compute probabilities over all observations of this stimulus
  lp_z_given_y$z_given_y_ONE = rowSums(sapply(observations_this_stimulus, 
                                              function(x){ score_z_ij_given_y(x, 1, grid_epsilon)}))
  lp_z_given_y$z_given_y_ZERO = rowSums(sapply(observations_this_stimulus, 
                                               function(x){ score_z_ij_given_y(x, 0, grid_epsilon)}))
  
  # clever expansion with cached likelihoods
  lp_z_y_theta <- expand_grid(lp_y_given_theta_one, lp_z_given_y) %>% 
    left_join(lp_y_given_theta_two, by = "theta") %>% 
    mutate(log_gamma = log(gamma), 
           log_1minusgamma = log(1-g))
  
  # NEEDS TO BE FIXED TO TAKE CARE OF THE ROWWISE THINGS
  
  
  lp_z_y_theta$calculation_y_ONE_theta_ONE <- lp_z_y_theta$lp_y_ONE_given_theta_ONE + log(gamma) + lp_z_y_theta$lp_theta_one
  lp_z_y_theta$calculation_y_ONE_theta_TWO <- lp_z_y_theta$lp_y_ONE_given_theta_TWO + log(1-gamma) + lp_z_y_theta$lp_theta_two
  lp_z_y_theta$calculation_y_ONE_theta_2concepts <-  rowLogSumExps(as.matrix(lp_z_y_theta[, c("calculation_y_ONE_theta_ONE", 
                                                                                    "calculation_y_ONE_theta_TWO")])) 
  lp_z_y_theta$calculation_given_y_ONE <- lp_z_y_theta$z_given_y_ONE + lp_z_y_theta$calculation_y_ONE_theta_2concepts
  
  
  lp_z_y_theta$calculation_y_ZERO_theta_ONE <- lp_z_y_theta$lp_y_ZERO_given_theta_ONE + log(gamma) + lp_z_y_theta$lp_theta_one
  lp_z_y_theta$calculation_y_ZERO_theta_TWO <- lp_z_y_theta$lp_y_ZERO_given_theta_TWO + log(1-gamma) + lp_z_y_theta$lp_theta_two
  lp_z_y_theta$calculation_y_ZERO_theta_2concepts <-  rowLogSumExps(as.matrix(lp_z_y_theta[, c("calculation_y_ZERO_theta_ONE", 
                                                                                    "calculation_y_ZERO_theta_TWO")])) 
  lp_z_y_theta$calculation_given_y_ZERO <- lp_z_y_theta$z_given_y_ZERO + lp_z_y_theta$calculation_y_ZERO_theta_2concepts
  
  
  lp_z_y_theta$z_given_theta <- rowLogSumExps(as.matrix(lp_z_y_theta[, c("calculation_given_y_ONE", 
                                                                                    "calculation_given_y_ZERO")]))  
 
 # NOT USRE HOW TO PROCEED, weird, maybe th emath is wrong 
  
  # add in likelihood for last sample from last stimulus, which includes all prior obs 
  # feels like this needs to be related to how we are enumerating different possibilities
  if (this_stimulus_idx > 1) {
    last_stim_last_t <- max(model$t[model$stimulus_idx == this_stimulus_idx - 1], na.rm=TRUE)
    this_lp_z_given_theta$lp_z_given_theta <- this_lp_z_given_theta$lp_z_given_theta + 
      lp_z_given_theta[[last_stim_last_t]][[f]]$lp_z_given_theta
  }
  
  return(this_lp_z_given_theta)
}

```


# MAYBE I SHOULD TRY A SIMPLER CASE WITH JUST BETA COUNT ACCUMULATION? 

```{r}
theta_grid <- seq(0.0001, 1, 0.01)

theta_one_alpha <- 10
theta_one_beta <- 1

theta_two_alpha <- 1
theta_two_beta <- 10

# chances of it seeing the concept from ONE 
gamma <- .6

update <- function(prior, observation){
  
  if(observation){
    
    theta_one_alpha = theta_one_alpha + gamma * length(observation)
    theta_two_alpha = theta_one_alpha + (1-gamma) * length(observation)
    
  }else{
    
    theta_one_beta = theta_one_beta + gamma * length(observation)
    theta_two_beta = theta_two_beta + (1-gamma) * length(observation)
    
  }
  
  # we will end up having two pairs of prior 
  
}

```




