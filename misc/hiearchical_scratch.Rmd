---
title: "scratch rmd for hiearchical"
author: "anjie & gal"
date: "12/15/2021"
output: html_document
---

```{r}
library(tidyverse)
```

some sketch for lambda 
```{r}


# ---------------- score_yi_given_theta ---------------------
choose_world_with_lambda <- function(w, lambda){
  # a cooler way to say that if w = 1 then theta if yi = 0 then yi = 1-theta? 
  dbinom(w, size = 1, prob = lambda, log = TRUE)
}

# ---------------- score_theta ---------------------
score_lambda <- function(lambda, alpha_lambda, beta_lambda){
  dbeta(x = lambda, shape1 = alpha_lambda, shape2 = beta_lambda, log = TRUE)
}
```


# stuff we need for two concepts world 

```{r}
test_model <- initialize_model(0.2, 20, 1)
test_model$t[1:10] <- seq(1, 10)
test_model$stimulus_idx[1:10] <- c(1, 1, 1, 2, 2, 3, 3, 3, 4, 4)
test_model$f1[1:10] <- rep(TRUE, 10)

test_model
```

# all for single concept right now, 

```{r}
# a list of dataframes that keep tracks of all the combinations possible 
# index corresponds to trial number 
# dataframes correspond to 
initialize_two_concepts_combinations <- function(total_trial_number){
  
  lapply(1:total_trial_number, 
         function(trial_number){
            as.matrix(expand.grid(as.data.frame(sapply(1:trial_number, 
                  FUN = function(i){c(1,2)}))))
         })
  
}
all_two_concepts_combination <- initialize_two_concepts_combinations(4)
current_stimulus_two_concept_combination <- all_two_concepts_combination[[4]]

# a function to index into the observation so that we can update the theta accordingly 

# a loop to go through all the possibilities 
i = 8
current_combo <- current_stimulus_two_concept_combination[i, ]

get_observation_for_concept <- function(concept, current_combo, model){

  # stimuli that comes from the specific concept 
  stimuli_from_concept <- which(current_combo == concept)
  
  # observation from those stimuli 
  obs_t <- (model$t[model$stimulus_idx %in% stimuli_from_concept])[!is.na(model$t[model$stimulus_idx %in% stimuli_from_concept])]

  return(obs_t)
  
}

obs_t_from_concept_one <- get_observation_for_concept(1, current_combo, model)
obs_t_from_concept_two <- get_observation_for_concept(2, current_combo, model)


# a function that put all the pieces together for likelihood in two world concept 
# takes gamma, needs to take into account of what the 


update_theta <- function(concept, observations){
  
  
}

```





now we are going to pretend that we are in a two concepts only world 

first we will set up the data frame to keep track fo the two thetas 

these two currently look identical so maybe they are indeed identical 
```{r}
grid_theta = seq(0.1, 1, 0.2)
grid_epsilon = seq(0.1, 1, 0.2)


theta_one_alpha = 10
theta_one_beta = 1

theta_two_alpha = 1
theta_two_beta = 10


gamma <- 0.6

lp_y_given_theta_one = tibble(theta = grid_theta, 
                            lp_theta_one = score_theta(grid_theta, theta_one_alpha, theta_one_beta),
                            lp_y_ONE_given_theta_ONE = score_yi_given_theta(yi = 1, 
                                                                     theta = grid_theta), 
                            lp_y_ZERO_given_theta_ONE = score_yi_given_theta(yi = 0, 
                                                                      theta = grid_theta))
 
lp_y_given_theta_two = tibble(theta = grid_theta, 
                            lp_theta_two = score_theta(grid_theta, theta_two_alpha, theta_two_beta),
                            lp_y_ONE_given_theta_TWO = score_yi_given_theta(yi = 1, 
                                                                     theta = grid_theta), 
                            lp_y_ZERO_given_theta_TWO = score_yi_given_theta(yi = 0, 
                                                                      theta = grid_theta))
  
  
  

  
lp_z_given_theta <- initialize_z_given_theta(grid_theta, grid_epsilon, 
                                                  20, # max observation 
                                                  1) # n features

# lp_z_given_theta is probably not going to change so we good here 

lp_z_given_theta[[1]]


model <- initialize_model(0.06, 20, 1)
model$t[1] <- 1
model$stimulus_idx[1] <- 1
model$f1[1] <- TRUE
model
```


```{r}



# ---------------- score_z_given_theta ---------------------
# Pretend we are always having two concepts
# main function updating likelihood
# returns a dataframe of cumulative log probabilities, p(z | theta)
  score_z_given_theta <- function(t, # timestep
                                f, # feature
                                lp_y_given_theta_one, # cached likelihoods
                                lp_y_given_theta_two, 
                                lp_z_given_theta, # more complicated 
                                model) {
  
  # set up current variables
  this_lp_z_given_theta <- lp_z_given_theta[[t]][[f]]

  grid_epsilon <- unique(this_lp_z_given_theta$epsilon) # just to get the value
  grid_theta <- unique(this_lp_z_given_theta$theta)
  
  
  this_stimulus_idx <- model$stimulus_idx[t]
  
  # need to compute over all noisy observations of this stimulus
  observations_this_stimulus <- filter(model, stimulus_idx == this_stimulus_idx) %>%
    select(paste0("f", f)) %>%
    pull()
  
  # initialize log p(z|y)
  lp_z_given_y = tibble(epsilon = grid_epsilon)
  
  # compute probabilities over all observations of this stimulus
  lp_z_given_y$z_given_y_ONE = rowSums(sapply(observations_this_stimulus, 
                                              function(x){ score_z_ij_given_y(x, 1, grid_epsilon)}))
  lp_z_given_y$z_given_y_ZERO = rowSums(sapply(observations_this_stimulus, 
                                               function(x){ score_z_ij_given_y(x, 0, grid_epsilon)}))
  
  # clever expansion with cached likelihoods
  lp_z_y_theta <- expand_grid(lp_y_given_theta_one, lp_z_given_y) %>% 
    left_join(lp_y_given_theta_two, by = "theta") %>% 
    mutate(log_gamma = log(gamma), 
           log_1minusgamma = log(1-g))
  
  # NEEDS TO BE FIXED TO TAKE CARE OF THE ROWWISE THINGS
  
  
  lp_z_y_theta$calculation_y_ONE_theta_ONE <- lp_z_y_theta$lp_y_ONE_given_theta_ONE + log(gamma) + lp_z_y_theta$lp_theta_one
  lp_z_y_theta$calculation_y_ONE_theta_TWO <- lp_z_y_theta$lp_y_ONE_given_theta_TWO + log(1-gamma) + lp_z_y_theta$lp_theta_two
  lp_z_y_theta$calculation_y_ONE_theta_2concepts <-  rowLogSumExps(as.matrix(lp_z_y_theta[, c("calculation_y_ONE_theta_ONE", 
                                                                                    "calculation_y_ONE_theta_TWO")])) 
  lp_z_y_theta$calculation_given_y_ONE <- lp_z_y_theta$z_given_y_ONE + lp_z_y_theta$calculation_y_ONE_theta_2concepts
  
  
  lp_z_y_theta$calculation_y_ZERO_theta_ONE <- lp_z_y_theta$lp_y_ZERO_given_theta_ONE + log(gamma) + lp_z_y_theta$lp_theta_one
  lp_z_y_theta$calculation_y_ZERO_theta_TWO <- lp_z_y_theta$lp_y_ZERO_given_theta_TWO + log(1-gamma) + lp_z_y_theta$lp_theta_two
  lp_z_y_theta$calculation_y_ZERO_theta_2concepts <-  rowLogSumExps(as.matrix(lp_z_y_theta[, c("calculation_y_ZERO_theta_ONE", 
                                                                                    "calculation_y_ZERO_theta_TWO")])) 
  lp_z_y_theta$calculation_given_y_ZERO <- lp_z_y_theta$z_given_y_ZERO + lp_z_y_theta$calculation_y_ZERO_theta_2concepts
  
  
  lp_z_y_theta$z_given_theta <- rowLogSumExps(as.matrix(lp_z_y_theta[, c("calculation_given_y_ONE", 
                                                                                    "calculation_given_y_ZERO")]))  
 
 # NOT USRE HOW TO PROCEED, weird, maybe th emath is wrong 
  
  # add in likelihood for last sample from last stimulus, which includes all prior obs 
  # feels like this needs to be related to how we are enumerating different possibilities
  if (this_stimulus_idx > 1) {
    last_stim_last_t <- max(model$t[model$stimulus_idx == this_stimulus_idx - 1], na.rm=TRUE)
    this_lp_z_given_theta$lp_z_given_theta <- this_lp_z_given_theta$lp_z_given_theta + 
      lp_z_given_theta[[last_stim_last_t]][[f]]$lp_z_given_theta
  }
  
  return(this_lp_z_given_theta)
}

```


# MAYBE I SHOULD TRY A SIMPLER CASE WITH JUST BETA COUNT ACCUMULATION? 

```{r}
theta_grid <- seq(0.0001, 1, 0.01)

theta_one_alpha <- 10
theta_one_beta <- 1

theta_two_alpha <- 1
theta_two_beta <- 10

# chances of it seeing the concept from ONE 
gamma <- .6

update <- function(prior, observation){
  
  if(observation){
    
    theta_one_alpha = theta_one_alpha + gamma * length(observation)
    theta_two_alpha = theta_one_alpha + (1-gamma) * length(observation)
    
  }else{
    
    theta_one_beta = theta_one_beta + gamma * length(observation)
    theta_two_beta = theta_two_beta + (1-gamma) * length(observation)
    
  }
  
  # we will end up having two pairs of prior 
  
}

```




