---
title: "callaway2021"
author: "anjie"
date: "4/19/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(here)
```

We consider simple choice problems in which a decision maker (DM) is presented with a set of items (e.g., snacks) and must choose one. 
- $i$: item
- $u^{(i)}$: the utility that the DM would gain by choosing it 


DM's belief about the item values at time t is described by a set of Gaussians, one for each item
- $\mu^{(i)}_{t}$: means of the gaussian 
- $\lambda^{(i)}_{t}$: the precision is the inverse of the variance 

these estimated value distributions are initialized to the DM's prior belief about the distribution of values in the environment. that is, she assummes that: 

$u^{(i)} ~ \sim Gaussians(\overline{\mu}, \overline{\sigma }^{2})$

and consequently set 

$\mu^{(i)}_{0} = \overline{\mu}$
$\lambda^{(i)}_{0} = \overline{\sigma }^{2}$

for all i. 

We model the control of attention as the selection of cognitive operations, $c_{t}$ that specify either an item to sample, or the termination of sampling. if the DM wishes to sample from item c at tiem-step t. she selects $c_{t} = c$ and receives a signal 


```{r}

unknown_true_value_for_c = 0
fp_amount_of_noise = 1

signal_for_c = rnorm(100, 
                     unknown_true_value_for_c, 
                     fp_amount_of_noise ^ 2)


hist(signal_for_c)
```

```{r}
percision_at_time_t0 = 0.2
utility_at_t0 = .1

precision_at_t1 = percision_at_time_t0 + fp_amount_of_noise ^ (-2)
utilitiy_at_t1 = (fp_amount_of_noise ^ (-2) * sample(signal_for_c, 1) + percision_at_time_t0 * utility_at_t0) / precision_at_t1

precision_at_t1
utilitiy_at_t1
  
```




# need to better understand the relationship betwee noise in the signal and the estimated precision etc 


```{r}
# belief about the item 
b_mu = 1
b_variance = 0.1 
b_precision = 1/b_variance 

b_prior_distribution = rnorm(100, 
                b_mu, 
                b_variance)
b_prior = sample(b_prior_distribution, 1)


# signal received after choosing the item 
s_mu = 0.8 # unknown true value of item being sampled 
s_variance = 0.1 # the amount of noise in each signal 
s_precision = 1/s_variance

s_x_distribution = rnorm(100, 
                       s_mu, 
                       s_variance)
s_x = sample(s_x_distribution, 1)

# update the belief after receiving the item 
b_new_precision = b_precision + s_precision 
b_posterior = ((s_precision * s_x) + (b_precision * b_prior)) / b_new_precision




```


```{r}
calculate_KL_between_gaussian <- function(mu1, mu2, sig1, sig2){
    
  return(log(sig2/sig1) + (sig1^2 + (mu1-mu2)^2)/(2*(sig2^2)) - 1/2)
}


calculate_probability <- function(mu, sigma, value){
  return (pnorm(value, mean = mu, sd = sigma, lower.tail = FALSE))
}
```

```{r}
n <- 100
s_mu = 5 # unknown true value of item being sampled 
s_variance = 1.8 # the amount of noise in each signal
b_prior <- 10
b_variance_prior <- .5

update_precision <- function(prior_belief_precision, signal_precision){
  return (prior_belief_precision + signal_precision)
}

update_belief <- function(signal_precision, 
                          signal_value, 
                          belief_precision, 
                          belief_value, 
                          updated_signal_precision){
  
  updated_belief <- ((signal_precision * signal_value) + (belief_precision * belief_value)) /
    updated_signal_precision
  
  return (updated_belief)

}
# belief about the item 
example <- data_frame(time_point = 1:n,
                      b_mu = b_prior,
                      b_variance = b_variance_prior,
                      b_precision = 1/b_variance,
                      s_precision = 1/s_variance,
                      s_x = rnorm(n, s_mu, s_variance^.5)) # signal received after choosing the item 

# pretend to have 100 time points 
for (i in 2:n) {
  example$b_precision[i] <- update_precision(example$b_precision[i-1], example$s_precision[1])
  
  example$b_mu[i] <- update_belief(example$s_precision[1], example$s_x[i], example$b_precision[i-1], 
                               example$b_mu[i-1], example$b_precision[i])
}

ggplot(example, aes(x = time_point, y = b_mu)) + 
  geom_line() + 
  geom_hline(yintercept = 5, lty = 2)
```


```{r}
# signal received after choosing the item 
s_mu = 5 # unknown true value of item being sampled 
s_variance = 3 # the amount of noise in each signal, varying this will change the curve of KL. more noise slower habituation 
s_precision = 1/s_variance

s_x_distribution = rnorm(100, 
                       s_mu, 
                       s_variance)
s_x = sample(s_x_distribution, 1)

# pretend to have 100 time points 
belief_precision_vector <- c(b_precision)
belief_mu_vector <- c(b_mu)
observation_vector <- c(s_x)

for (i in 1:100){
  
  current_belief_precision = belief_precision_vector[i]
  current_belief_mu = belief_mu_vector[i]
  
  s_mu = 5 # unknown true value of item being sampled 
  s_variance = 3 # the amount of noise in each signal, varying this will change the curve of KL. more noise slower habituation 
    s_precision = 1/s_variance

  s_x_distribution = rnorm(100, 
                       s_mu, 
                       s_variance^.5)
  s_x = sample(s_x_distribution, 1)
  
  observation_vector <- c(observation_vector, s_x)
  
  updated_belief_precision = update_precision(current_belief_precision, 
                                       s_precision)
  
  updated_mu = update_belief(s_precision,
                             s_x, 
                             current_belief_precision, 
                             current_belief_mu, 
                             updated_belief_precision)
  
  belief_precision_vector <- c(belief_precision_vector, updated_belief_precision)
  belief_mu_vector <- c(belief_mu_vector, updated_mu)
  
}

blurrier_example <- tibble("time_point" = seq(1, 101, 1),
       "belief" = belief_mu_vector, 
       
       "precision" = belief_precision_vector, 
       "observation" = observation_vector,
) %>% 
  mutate("variance" = 1/precision) %>% 
  mutate(noise_in_signal = s_variance)
```



https://stats.stackexchange.com/questions/7440/kl-divergence-between-two-univariate-gaussians


```{r}
example

kls <- c()
for (t in 2:101){

  mu1 <- example %>% 
    filter(time_point == t-1) %>%
    select(belief) %>% 
    pull()
  
  sig1 <- (example %>% 
    filter(time_point == t-1) %>%
    select(variance) %>% 
    pull()) ^ .5
  
  mu2 <- example %>% 
    filter(time_point == t) %>% 
    select(belief) %>% 
    pull()
  
  sig2 <- (example %>% 
    filter(time_point == t) %>%
    select(variance) %>% 
    pull()) ^ .5
  
  kl <- calculate_KL_between_gaussian(mu1, mu2, sig1, sig2)
  kls <- c(kls, kl)
  
}

example_with_kl <- example %>% 
  filter(time_point != 1)

example_with_kl$kl <- kls

example_with_kl %>% 
  ggplot(aes(x = time_point, 
                    y = kl)) + 
  geom_point() + 
  geom_line()
```

```{r}
kls <- c()
for (t in 2:101){

  mu1 <- blurrier_example %>% 
    filter(time_point == t-1) %>%
    select(belief) %>% 
    pull()
  
  sig1 <- (blurrier_example %>% 
    filter(time_point == t-1) %>%
    select(variance) %>% 
    pull()) ^ .5
  
  mu2 <- blurrier_example %>% 
    filter(time_point == t) %>% 
    select(belief) %>% 
    pull()
  
  sig2 <- (blurrier_example %>% 
    filter(time_point == t) %>%
    select(variance) %>% 
    pull()) ^ .5
  
  kl <- calculate_KL_between_gaussian(mu1, mu2, sig1, sig2)
  kls <- c(kls, kl)
  
}

blurrier_example_with_kl <- blurrier_example %>% 
  filter(time_point != 1)

blurrier_example_with_kl$kl <- kls
```

```{r}
bind_rows(blurrier_example_with_kl, example_with_kl) %>% 
  mutate(noise_level = if_else(noise_in_signal == 1.8, "low", "high")) %>% 
  filter(time_point < 25) %>% 
  ggplot(aes(x = time_point, 
                    y = kl, 
             color = noise_level)) + 
  geom_point() + 
  geom_smooth(method = "lm", 
              formula = y ~ I(exp(1)**(-x)), se = FALSE)
```



```{r}
# the probablity of getting the observation X given the prior belief 
probs <- c()
for (t in 2:101){
  
  observation <- example %>% 
    filter(time_point == t) %>%
    select(observation) %>% 
    pull()
  
  prior_belief_mu <- example %>% 
    filter(time_point == t-1) %>%
    select(belief) %>% 
    pull()
  
  prior_belief_sigma <- (example %>% 
    filter(time_point == t-1) %>%
    select(variance) %>% 
    pull()) ^ .5
  
  prob <- calculate_probability(prior_belief_mu, 
                                prior_belief_sigma, 
                                observation)
  
  probs <- c(probs, prob)
 
}


example_with_probs <- example %>% 
  filter(time_point != 1)

example_with_probs$prob <- probs

example_with_probs %>% 
  ggplot(aes(x = time_point, 
                    y = probs)) + 
  geom_point() + 
  geom_line()

example_with_probs %>% 
  mutate(surprise = -log(prob)) %>% 
  ggplot(aes(x = time_point, 
                    y = surprise)) + 
  geom_point() + 
  geom_line()
```







```{r}
# belief about the item 
b_mu = .2
b_variance = 0.3

b_precision = 1/b_variance 

b_prior_distribution = rnorm(100, 
                b_mu, 
                b_variance)
b_prior = sample(b_prior_distribution, 1)


# signal received after choosing the item 
s_mu = 5 # unknown true value of item being sampled 
s_variance = c(0.5, 1, 1.5) # the amount of noise in each signal, varying this will change the curve of KL. more noise slower habituation 
s_precision = 1/s_variance

s_x_distribution = rnorm(100, 
                       s_mu, 
                       s_variance)
s_x = sample(s_x_distribution, 1)

```


























# what if we put them into vectors? 

```{r}
update_precision_vector <- function(prior_belief_precision_vector, 
                             signal_precision_vector){
  return (prior_belief_precision + signal_precision)
}

update_belief <- function(signal_precision, 
                          signal_value, 
                          belief_precision, 
                          belief_value, 
                          updated_signal_precision){
  
  updated_belief <- ((signal_precision * signal_value) + 
                       (belief_precision * belief_value)) / updated_signal_precision
  
  return (updated_belief)

}
```



```{r}
stimuli <- c(1, 0, 1)

stimuli_b_mu = c(.5, .5, .5)
stimuli_b_variance = c(.3, .3, .3)
stimuli_b_precision = 1/stimuli_b_variance
stimuli_b_prior = c()

for (i in 1: length(stimuli_b_mu)){
  
  b_prior = sample(rnorm(100, 
                stimuli_b_mu[i], 
                stimuli_b_variance[i]), 1)
  
  stimuli_b_prior = c(stimuli_b_prior, b_prior)
  
}


# signal received after choosing the item 
stimuli_s_mu = stimuli # unknown true value of item being sampled 
stimuli_s_variance = c(0.1, 0.1, 0.1) # the amount of noise in each signal, maybe can be changed as a function of exposure duration? 
stimuli_s_precision = 1/stimuli_s_variance
stimuli_s_prior = c()

for (i in 1: length(stimuli_s_mu)){
  
  s_prior = sample(rnorm(100, 
                stimuli_s_mu[i], 
                stimuli_s_variance[i]), 1) # shouldn't be negative, logit? 
  
  stimuli_s_prior = c(stimuli_s_prior, s_prior)
  
}


# pretend to have 100 time points 
belief_precision_list <- list(stimuli_b_precision)
belief_mu_list <- list(stimuli_b_mu)

for (i in 1:3){
  
  current_belief_precision_vector = belief_precision_list[[i]]
  current_belief_mu_vector = belief_mu_list[[i]]
  
  updated_belief_precision_vector = list(update_precision(current_belief_precision_vector, 
                                       stimuli_s_precision))
  
  updated_mu_vector = list(update_belief(stimuli_s_precision,
                             stimuli_s_mu, 
                             current_belief_precision_vector, 
                             current_belief_mu_vector, 
                             updated_belief_precision_vector[[1]]))
  
  belief_precision_list <- c(belief_precision_list, 
                             updated_belief_precision_vector)
  #belief_mu_list[[i+1]] <- updated_mu_vector
  belief_mu_list <- c(belief_mu_list, updated_mu_vector)
  
}

example <- tibble("time_point" = seq(1, 101, 1),
       "belief" = belief_mu_vector, 
       "precision" = belief_precision_vector, 
) %>% 
  mutate("variance" = 1/precision)

```




