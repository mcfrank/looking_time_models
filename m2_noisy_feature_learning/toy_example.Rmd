---
title: "toy example"
author: "anjie & gal "
date: "6/23/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(microbenchmark)
library(tidyverse )
```

criteria for toy example: 
- keep track of both characters and numrics (so data type is important)
- column based -> row based 

currently: 
  - we have three types of apply, lapply, sapply, mapply. 
  
# performance difference? 

adapt this code: 
https://www.analyticskhabar.com/apply-vs-lapply-vs-mapply-vs-tapply-vs-sapply/

```{r}

create_df_tibble  <- function(nrow){
  base_df <- tibble(
  "one" = rep(1, nrow), 
  "two" = rep(2, nrow))

}


#expand_function <- function()
  

t <- create_df_tibble(1000) 
```

# avoid pull operation at all costs 

maybe we want to revert all select back to base r syntax 
=> select is bad, maybe
```{r}
microbenchmark( a <- t['one'],
                a <-  t %>% select(one),
                a <- t$one,
                a <- t %>% pull(one),
                t$three <- t$two + 1,
                a <- t %>% mutate(three = two + 1),
                a <- t %>% filter(one == 1), 
                a <- t[t$one == 1,],
              times = 10)

```

# sum in r 
```{r}
l <- seq(1, 1000000000, 1)

microbenchmark( sum(l),
                matrixStats::sum2(l),
              times = 10)

```

# pipeline 
```{r}
library(bench)
library(magrittr)


bm <- bench::mark(
   x <- t[startsWith(names(t), "V")],
   x <- t %>% select(starts_with("V"))
)
ggplot2::autoplot(bm)
```

```{r}
df <- tibble("char" = c("a", "a", "b", "b"), 
             "num" = c(1, 1, 1, 1))



bm <- bench::mark(
   x <- df %>% group_by(char) %>% summarise(sum = sum(num)),
   
)
ggplot2::autoplot(bm)

microbenchmark(
   x <- df %>% group_by(char) %>% summarise(sum = sum(num)),
   x <- aggregate(df$num,             # Sum by group
          by = list(df$char),
          FUN = sum),
   times = 100
)
```



# operation on each feature 

```{r}
df_lapply_operation <- function(df){
  
  res <- lapply(seq(1, ncol(df), 1), 
         
         function(x){
           y <- tibble((df[,x]) + 1)
         }
         ) %>% 
      bind_rows()
  
  return(res)
}


df_sapply_operation <- function(df){
  
  res <- sapply(seq(1, ncol(df), 1), 
         
         function(x){
           y <- tibble((df[,x]) + 1)
         }
         ) %>% 
      bind_rows()
  
  return(res)
}

df_mapply_operation <- function(df){
  
  res <- mapply(
         
         function(x, y){
           x+y
         }, 
        df$one, df$two         
         ) 

  return(res)
}

df_lapply_operation(t)

microbenchmark(df_lapply_operation(t),
               df_sapply_operation(t),
               df_mapply_operation(t),
              times = 100)

```

```{r}
a <- seq(1, 99, 1)
b <- seq(1, 99, 1)

exp_g  <- function(m, n){
  a <- seq(1, m, 1)
  b <- seq(1, n, 1)
  res <- tidyr::expand_grid(a = a, 
                     b = b)
  return (res)
}

allocate <- function(m, n){
  df <- tibble("a" = seq(1))
  
}

microbenchmark(
  
  exp_g(10, 10),
              times = 100)
```

