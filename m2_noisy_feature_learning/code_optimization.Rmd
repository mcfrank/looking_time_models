---
title: "R Notebook"
output: html_notebook
---


http://winvector.github.io/Accumulation/Accum.html








```{r}
library(tidyverse)
library(here)
library(matrixStats)
library(profvis)

source(here("helper/get_stimuli.R"))
source(here("helper/get_observation.R"))
source(here("helper/grid_approximation.R"))
source(here("helper/noisy_update.R"))
source(here("helper/main_simulation.R"))
source(here("helper/get_kl_eig.R"))

```

```{r}
num_features = 1
num_features_simple = 1
num_feature_complex = 6
trials_per_block = 3
deviant_positions = 2
feature_theta = 0.9
dissimilarity_ratio = 0.9
noise_parameter = 0.1

## grid approximation related 
grid_theta <- seq(0.1, 1, 0.2)
grid_epsilon <- seq(0.1, 1, 0.2)
alpha_prior = 1
beta_prior = 1
alpha_epsilon = 10 
beta_epsilon = 1

## eig related 
env_eig = 0.005
max_obs = 500

## experiment related 
subject_n = 10
```

```{r, include=FALSE}
simple_stimuli <- generate_creature_sequence(
  block_length = trials_per_block, 
  deviant_positions = deviant_positions,  # takes a vector, 
  total_feature = num_features, 
  feature_theta = feature_theta, 
  feature_number = num_features_simple, 
  dissimilar_ratio = dissimilarity_ratio)

```




```{r}
library(microbenchmark)
library(profvis)

subject_n = 10

no_optimization <- function(){

sims <- lapply(seq(1, subject_n, 1), 
         function(x){
           main_simulation(subject = x,
                          stimuli_sequence = simple_stimuli, 
                          noise_parameter = noise_parameter, 
                          eig_from_world = env_eig,
                          max_observation = max_obs, # should this be per trial or in total? currently per trial 
                          grid_theta = grid_theta, 
                          grid_epsilon = grid_epsilon, 
                          alpha_prior = alpha_prior, 
                          beta_prior = beta_prior,
                          alpha_epsilon = alpha_epsilon, 
                          beta_epsilon = beta_epsilon, 
                          forced_exposure = TRUE,
                          forced_sample = 5,
                          optimize = FALSE)
         }
  ) %>% 
    bind_rows()
}

with_optimization <- function(){
  
  sims <- lapply(seq(1, subject_n, 1), 
         function(x){
           main_simulation(subject = x,
                          stimuli_sequence = simple_stimuli, 
                          noise_parameter = noise_parameter, 
                          eig_from_world = env_eig,
                          max_observation = max_obs, # should this be per trial or in total? currently per trial 
                          grid_theta = grid_theta, 
                          grid_epsilon = grid_epsilon, 
                          alpha_prior = alpha_prior, 
                          beta_prior = beta_prior,
                          alpha_epsilon = alpha_epsilon, 
                          beta_epsilon = beta_epsilon, 
                          forced_exposure = TRUE,
                          forced_sample = 5,
                          optimize = TRUE)
         }
  ) %>% 
    bind_rows()
  
  
}

# profvis(no_optimization())
profvis(with_optimization())
#with_optimization()

#microbenchmark(no_optimization(), 
 #              with_optimization(),times = 10)


```



```{r}
ptm <- proc.time()


sims_lapply <- lapply(seq(1, subject_n, 1), 
         function(x){
           main_simulation_toggle(subject = x,
                                  observation_assumption = "independent",
                          stimuli_sequence = simple_stimuli, 
                          noise_parameter = epsilon, 
                          eig_from_world = env_eig,
                          max_observation = max_obs, # should this be per trial or in total? currently per trial 
                          grid_theta = grid_theta, 
                          grid_epsilon = grid_epsilon, 
                          alpha_prior = alpha_prior, 
                          beta_prior = beta_prior,
                          alpha_epsilon = alpha_epsilon, 
                          beta_epsilon = beta_epsilon)
         }
  )

data.table::rbindlist(sims_lapply)
proc.time() - ptm

```

```{r}

temp_file <- tempfile()
file.create(temp_file)
cf <- file(temp_file, open = "a")

ptm <- proc.time()

sims_lapply <- lapply(seq(1, subject_n, 1), 
         function(x){
           main_simulation_toggle(subject = x,
                                  observation_assumption = "independent",
                          stimuli_sequence = simple_stimuli, 
                          noise_parameter = epsilon, 
                          eig_from_world = env_eig,
                          max_observation = max_obs, # should this be per trial or in total? currently per trial 
                          grid_theta = grid_theta, 
                          grid_epsilon = grid_epsilon, 
                          alpha_prior = alpha_prior, 
                          beta_prior = beta_prior,
                          alpha_epsilon = alpha_epsilon, 
                          beta_epsilon = beta_epsilon)
         }
  )
proc.time() - ptm


close(cf)
read.table(temp_file, 
           header = TRUE, 
           stringsAsFactors = FALSE)

```







```{r}
id_lens <- independence_sims %>%
  group_by(stimulus_idx, id) %>%
  summarise(length = n()) %>%
  filter(!is.na(stimulus_idx))

ggplot(id_lens, aes(x = stimulus_idx, y = length)) + 
  geom_point() 
```

```{r}
sims %>% 
  ggplot(aes(x = t, y = EIG, fill = stimulus_idx)) + 
  geom_point()

independence_sims %>% 
  ggplot(aes(x = t, y = EIG)) + 
  geom_point()
```

```{r}
saveRDS(independence_sims, file = "old_calculation.RDS")
saveRDS(sims, file = "new_calculation.RDS")

```


ok try to treat ya 
```{r}
update_grid_with_theta_and_epsilon_better <- function(
  feature_i, 
  grid_theta, 
  grid_epsilon, 
  observations, 
  alpha_theta, beta_theta, 
  alpha_epsilon, beta_epsilon
){
  
  
  samps <- expand_grid(theta = grid_theta,
                       epsilon = grid_epsilon) 
  
  
  samps$unnormalized_log_posterior <- mapply(function(x, y) 
    lp_theta_given_z(z_bar = observations, 
                     theta = x, 
                     epsilon = y, 
                     alpha_theta = alpha_theta, 
                     beta_theta = beta_theta,
                     alpha_epsilon = alpha_epsilon, 
                     beta_epsilon = beta_epsilon), 
    samps$theta, 
    samps$epsilon)
  
  samps$log_posterior = samps$unnormalized_log_posterior - matrixStats::logSumExp(samps$unnormalized_log_posterior)
  
  # integrate out epsilon by summing p(theta | z) over all the different possible values of epsilon
  # that's the log-sum-exp line
  theta_posterior <- samps %>%
    group_by(theta) %>%
    summarise(log_posterior = matrixStats::logSumExp(log_posterior)) %>%
    mutate(posterior = exp(log_posterior)) %>% 
    mutate(feature_index = feature_i)
  
  return(theta_posterior)
  
}
```

so it turns out you are a huge problem, let's test you for a bit 



```{r}

observations = noisy_observation[,1]

lp_theta_given_z <- function(z_bar, 
                             theta, epsilon, 
                             alpha_theta, beta_theta, 
                             alpha_epsilon, beta_epsilon) {
 
  lp_z_given_theta(z_bar, theta, epsilon) + 
    lp_theta(theta, alpha_theta, beta_theta) + 
    lp_epsilon(epsilon, alpha_epsilon, beta_epsilon)
}


lp_z_given_theta_better <- function(z_bar, 
                             theta, 
                             epsilon){
  
  z_bar = z_bar %>% pull()
  sum(sapply(z_bar, 
             function(x){lp_z_ij_given_theta(zij = x, 
                                                    theta = theta, 
                                                    epsilon = epsilon)}))
  
  
}
```


so i think the issue is the sequential updating rule is kinda annoying, what if we do it in the more reasonable way? let's first test if we can actually have the equivalent results 

```{r}

stimulus_idx <- 1
current_stimulus <- simple_stimuli %>% 
      filter(trial_number == stimulus_idx)
  
observations <-  simple_stimuli %>% 
    # create an empty dataframe with all the info needed to be tracked 
    filter(is.na(.)) %>% 
    mutate(t = NA_integer_) 


o1 <- noisy_observation_creature(
                                stimuli_df = simple_stimuli,
                                trial_index  = 1, 
                                n_sample = 1, 
                                epsilon = noise_parameter
                              )
    
    # add to current observation 
o1 <- bind_rows(observations, 
                              o1 %>% mutate(
                                trial_number = stimulus_idx, 
                                trial_type = current_stimulus$trial_type,
                                t = 1))

o2 <- noisy_observation_creature(
                                stimuli_df = simple_stimuli,
                                trial_index  = 1, 
                                n_sample = 1, 
                                epsilon = noise_parameter
                              )

os <- bind_rows(o1, 
                              o2 %>% mutate(
                                trial_number = stimulus_idx, 
                                trial_type = current_stimulus$trial_type,
                                t = 2))
    
    # calculate posterior at t 
    # optimization possible!

```


yeah equivalent! maybe we should time them now! let's make them relatively expensive 

```{r}
thetas <- seq(0.1, .9, .2)
epsilons <- seq(0.1, .9, .2)
```


ughhhh awkward 
hypothesis: maybe it is because i'm not doing enough number of updates? maybe the benefit would show up in the long term? 

```{r}
o100 <- noisy_observation_creature(
                                stimuli_df = simple_stimuli,
                                trial_index  = 1, 
                                n_sample = 100, 
                                epsilon = noise_parameter
                              )

o100
```

let's try it out 
## 100 obs with the old way: 
```{r}
ptm <- proc.time()

 posterior_after_os <- grid_apprxoimation_with_observation(
                          noisy_observation = o100, 
                          track_epsilon = TRUE, 
                          grid_theta = thetas, 
                          grid_epsilon = epsilons, 
                          alpha_prior = alpha_prior, 
                          beta_prior = beta_prior,
                          alpha_epsilon = alpha_epsilon, 
                          beta_epsilon = beta_epsilon
                        )
 
 proc.time() - ptm
```

## 100 obs with the new way 
```{r}
ptm <- proc.time()


for (i in 1:100){

  obs <- o100[i, ]
  if (i == 1){
   pos_df <- faster_grid_apprxoimation_with_observation(
          timepoint = i, 
          noisy_observation = obs , 
          last_update_posterior_df = NULL, 
          track_epsilon = TRUE, 
          grid_theta = thetas, 
          grid_epsilon = epsilons, 
          alpha_prior = 1, 
          beta_prior = 1,
          alpha_epsilon = 10, 
          beta_epsilon = 1
   )
   }else {
      pos_df <- faster_grid_apprxoimation_with_observation(
          timepoint = i, 
          noisy_observation = obs , 
          last_update_posterior_df = pos_df, 
          track_epsilon = TRUE, 
          grid_theta = thetas, 
          grid_epsilon = epsilons, 
          alpha_prior = 1, 
          beta_prior = 1,
          alpha_epsilon = 10, 
          beta_epsilon = 1
   )

   }
}

 proc.time() - ptm


```
```{r}
posterior_after_os
pos_df
```

